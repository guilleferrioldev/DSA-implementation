import hashlib
import math
from typing import List

class Node:
    """Node implementation"""
    def __init__(self, data: str) -> None:
        self.data = data
        self.left = None
        self.right = None
    
    def isFull(self) -> bool:
        return self.left and self.right
    
    def __str__(self) -> str:
        return f"{self.data}"
    
    def isLeaf(self) -> bool:
        return ((self.left == None) and (self.right == None))

class MerkleTree:
    """Merkle Tree implementation"""
    def __init__(self, array: List[str] = None) -> None:
        self.root = None
        self._merkleRoot = ''
        
        if not array:
            return 
    
        self.makeTreeFromArray(array)
        
    def __returnHash(self, input_string: str) -> hashlib.sha256:
        """Private method to return a hash of an input string, using the sha256 algorithm  """
        return (hashlib.sha256(input_string.encode()).hexdigest())
           
    def makeTreeFromArray(self, arr: List[str]) -> None:
        """Method to generate a tree from a list."""
        
        def __noOfNodesReqd(arrarr: List[str]) -> int:
            """all the elements of the list must be leaf nodes, hence total nodes in the 
            tree is [2*(noOfLeafNodes) - 2]"""
            x = len(arr)
            return (2*x - 1)
        
        def __buildTree(arr, node: Node, index: int, number: int): 
            """function to build tree with a list generated by a sequence corresponding to the
            number of nodes required for the tree."""
       
            if index < number: 
                temp = Node(str(arr[index]))  
                node = temp  
 
                node.left = __buildTree(arr, node.left, 2 * index + 1, number)    
                node.right = __buildTree(arr, node.right, 2 * index + 2, number) 
                
            return node
              
        def __addLeafData(arr: List[str], node: Node) -> None:
            if not node:
                return
            
            __addLeafData(arr, node.left)
            if node.isLeaf():
                node.data = self.__returnHash(arr.pop())
            else:
                node.data = ''
            __addLeafData(arr, node.right)
        
        nodesReqd = __noOfNodesReqd(arr)
        nodeArr = [num for num in range(1,nodesReqd+1)]
        self.root = __buildTree(nodeArr, self.root, 0, nodesReqd)
        __addLeafData(arr,self.root)

    
    def calculateMerkleRoot(self) -> Node:
        """Method to calculate merkle root of the tree. This is a recursive algorithm."""
         
        def __merkleHash(node):
            if node.isLeaf():
                return node
            
            left = __merkleHash(node.left).data
            right = __merkleHash(node.right).data
            node.data = self.__returnHash(left+right)
            return node
        
        merkleRoot = __merkleHash(self.root)
        self._merkleRoot = merkleRoot.data
        
        return self._merkleRoot 

    def getMerkleRoot(self) -> Node:
        """Method to get the merkle Root of that tree"""
        return self._merkleRoot
    
    def verifyUtil(self, arr1: List[str]) -> bool:
        """ function to verify if the transactions are intact with respect to this tree. Say we know 
        transaction list A is intact and original. We create a merkle Tree with that."""
        hash1 = self.getMerkleRoot()
        new_tree = merkleTree()
        new_tree.makeTreeFromArray(arr1)
        new_tree.calculateMerkleRoot()
        hash2 = new_tree.getMerkleRoot()
        if hash1 == hash2 :
            print("Transactions verified Successfully")
            return True
        else:
            print("Transactions have been tampered")
            return False
        
    def _inorderTraversal(self, node: Node, arr: List[str]) -> None:
        """Method to traverse the tree using inorder Traversal algorithm"""
        if not node:
            return
        
        self._inorderTraversal(node.left, arr)
        arr.append(node.data)
        self._inorderTraversal(node.right, arr)
        
    def __repr__(self) -> str:
        result = []
        self._inorderTraversal(self.root, result)
        return f"{result}"